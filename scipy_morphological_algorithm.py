# -*- coding: utf-8 -*-

"""
/***************************************************************************
 SciPyFilters
                                 A QGIS plugin
 Filter collection implemented with SciPy
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-03-03
        copyright            : (C) 2024 by Florian Neukirchen
        email                : mail@riannek.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Florian Neukirchen'
__date__ = '2024-03-03'
__copyright__ = '(C) 2024 by Florian Neukirchen'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import json
import numpy as np
from osgeo import gdal
from scipy import ndimage
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterString,
                       QgsProcessingParameterBoolean,
                       QgsProcessingException,
                        )

from .scipy_algorithm_baseclasses import SciPyAlgorithm


class SciPyMorphologicalBaseAlgorithm(SciPyAlgorithm):
    """
    Base class for morphological filters.
    """

    ALGORITHM = 'ALGORITHM' 
    STRUCTURE = 'STRUCTURE'
    CUSTOMSTRUCTURE = 'CUSTOMSTRUCTURE'

    _groupid = 'morphological'

    def getAlgs(self):
        return ['Dilation', 'Erosion', 'Closing', 'Opening']
    

    def insert_parameters(self, config):

        self.algorithms = self.getAlgs()
        
        self.addParameter(QgsProcessingParameterEnum(
            self.ALGORITHM,
            self.tr('Filter'),
            self.algorithms,
            defaultValue=0)) 
        

        self.addParameter(QgsProcessingParameterEnum(
            self.STRUCTURE,
            self.tr('Structure'),
            ["Cross", "Square", "Custom"],
            defaultValue=1)) 

        self.addParameter(QgsProcessingParameterString(
            self.CUSTOMSTRUCTURE,
            self.tr('Custom structure (array), ignored if structure is set to cross or square'),
            defaultValue="[[1, 1, 1],\n[1, 1, 1],\n[1, 1, 1]]",
            multiLine=True,
            optional=True,
            ))
        
        super().insert_parameters(config)
           
    def get_parameters(self, parameters, context):
        kargs = super().get_parameters(parameters, context)

        self.alg = self.parameterAsInt(parameters, self.ALGORITHM, context)

        structure = self.parameterAsInt(parameters, self.STRUCTURE, context) 
        if structure in (0,1):
            kargs['structure'] = ndimage.generate_binary_structure(2,structure + 1)
        else:
            structure = self.parameterAsString(parameters, self.CUSTOMSTRUCTURE, context)
            kargs['structure'] = self.str_to_array(structure)

      
        return kargs

    def checkParameterValues(self, parameters, context): 
        structure = self.parameterAsInt(parameters, self.STRUCTURE, context)
        if structure == 2:
            structure = self.parameterAsString(parameters, self.CUSTOMSTRUCTURE, context)
            ok, s = self.check_structure(structure)
            if not ok:
                return (ok, s)
        
        return super().checkParameterValues(parameters, context)


class SciPyBinaryMorphologicalAlgorithm(SciPyMorphologicalBaseAlgorithm):

    ITERATIONS = 'ITERATIONS'
    MASK = 'MASK'
    BORDERVALUE = 'BORDERVALUE'

    # Overwrite constants of base class
    _name = 'binary_morphology'
    _displayname = 'Binary dilation, erosion, closing, opening'
    _outputname = 'Binary morphology' # If set to None, the displayname is used 
    _help = """
            Binary morphological filters: dilation, erosion, closing, and opening. \
            Calculated for every band with binary_dilation, \
            binary_erosion, binary_closing, binary_opening respectively from \
            <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

            <b>Dilation</b> Set pixel to maximum value of neighborhood. Remaining shapes are larger, lines are thicker.
            <b>Erosion</b> Set pixel to minimum value of neighborhood. Remaining shapes are smaller, lines are thinner.
            <b>Closing</b> Perform dilation and then erosion. Fills small holes, large shapes are preserved.
            <b>Opening</b> Perform erosion and then dilation. Removes small shapes, large shapes are preserved.
            
            <b>Structure</b> Structuring element of filter, can be cross, square or custom. 
            <b>Custom structure</b> String representation of array, only used if "Structure" is set to "Custom".
            <b>Iterations</b> Each step of filter is repeated this number of times.
            <b>Border value</b> Valute at border of output array, defaults to 0. 
            <b>Mask</b> Optional mask layer.
            """
    
    # The function to be called
    def get_fct(self):
        if self.alg == 1:
            fct = ndimage.binary_erosion
        elif self.alg == 2:
            fct = ndimage.binary_closing
        elif self.alg == 3:
            fct = ndimage.binary_opening
        else:
            fct = ndimage.binary_dilation
        
        return fct

 
    def initAlgorithm(self, config):
        super().initAlgorithm(config)

        self.addParameter(QgsProcessingParameterNumber(
            self.ITERATIONS,
            self.tr('Iterations'),
            QgsProcessingParameterNumber.Type.Integer,
            defaultValue=1, 
            optional=True, 
            minValue=1, 
            # maxValue=100
            ))    
        
        self.addParameter(QgsProcessingParameterEnum(
            self.BORDERVALUE,
            self.tr('Border value (value at border of output array)'),
            ["0","1"],
            optional=True,
            defaultValue=0))
        
        self.addParameter(
            QgsProcessingParameterRasterLayer(
                self.MASK,
                self.tr('Mask layer'),
                optional=True,
            )
        )

    def get_parameters(self, parameters, context):
        kargs = super().get_parameters(parameters, context)

        self.masklayer = self.parameterAsRasterLayer(parameters, self.MASK, context)

        iterations = self.parameterAsInt(parameters, self.MASK, context)
        if iterations:
            kargs['iterations'] = iterations

        bordervalue = self.parameterAsInt(parameters, self.BORDERVALUE, context)
        if bordervalue:
            kargs['border_value'] = bordervalue

        return kargs
    
    def createInstance(self):
        return SciPyBinaryMorphologicalAlgorithm()


  class SciPyGreyMorphologicalAlgorithm(SciPyMorphologicalBaseAlgorithm):

    SIZE = 'SIZE'
    MODE = 'MODE'
    CVAL = 'CVAL'
    FOOTPRINT = 'FOOTPRINT'
    BOOLFOOTPRINT = 'BOOLFOOTPRINT'

    modes = ['reflect', 'constant', 'nearest', 'mirror', 'wrap']

    # Overwrite constants of base class
    _name = 'grey_morphology'
    _displayname = 'Grey dilation, erosion, closing, opening'
    _outputname = 'Grey morphology' # If set to None, the displayname is used 
    _help = """
            Grey morphological filters: dilation, erosion, closing, and opening. \
            Calculated for every band with grey_dilation, \
            grey_erosion, gey_closing, grey_opening respectively from \
            <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

            <b>Dilation</b> Set pixel to maximum value of neighborhood. Remaining shapes are larger, lines are thicker.
            <b>Erosion</b> Set pixel to minimum value of neighborhood. Remaining shapes are smaller, lines are thinner.
            <b>Closing</b> Perform dilation and then erosion. Fills small holes, large shapes are preserved.
            <b>Opening</b> Perform erosion and then dilation. Removes small shapes, large shapes are preserved.
            
            <b>Structure</b> Structuring element of filter, can be cross, square or custom. 
            <b>Custom structure</b> String representation of array, only used if "Structure" is set to "Custom".
            <b>Size</b> Size of flat and full structuring element, optional if footprint or structure is provided.
            <b>Border mode</b> determines how input is extended around \
            the edges: <i>Reflect</i> (input is extended by reflecting at the edge), \
            <i>Constant</i> (fill around the edges with a <b>constant value</b>), \
            <i>Nearest</i> (extend by replicating the nearest pixel), \
            <i>Mirror</i> (extend by reflecting about the center of last pixel), \
            <i>Wrap</i> (extend by wrapping around to the opposite edge).
            <b>Footprint</b> Positions of elements of a flat structuring element used for the filter (string representation of array, only used if checkbox is checked).
            """
    
    # The function to be called
    def get_fct(self):
        if self.alg == 1:
            fct = ndimage.grey_erosion
        elif self.alg == 2:
            fct = ndimage.grey_closing
        elif self.alg == 3:
            fct = ndimage.grey_opening
        else:
            fct = ndimage.grey_dilation
        
        return fct

 
    def initAlgorithm(self, config):
        super().initAlgorithm(config)

        self.addParameter(QgsProcessingParameterNumber(
            self.SIZE,
            self.tr('Size of flat structuring element (Optional if footprint or structure provided, 0 for no size)'),
            QgsProcessingParameterNumber.Type.Integer,
            defaultValue=0, 
            optional=True, 
            minValue=0, 
            # maxValue=100
            ))    
        
        self.addParameter(QgsProcessingParameterEnum(
            self.MODE,
            self.tr('Border Mode'),
            [mode.capitalize() for mode in self.modes],
            defaultValue=0)) 
        
        self.addParameter(QgsProcessingParameterNumber(
            self.CVAL,
            self.tr('Constant value past edges for border mode "constant"'),
            QgsProcessingParameterNumber.Type.Double,
            defaultValue=0, 
            optional=True, 
            minValue=0, 
            # maxValue=100
            ))      
        
        self.addParameter(QgsProcessingParameterBoolean(
            self.BOOLFOOTPRINT,
            self.tr('Use footprint array'),
            defaultValue=False, 
            optional=True
            )) 
        

        self.addParameter(QgsProcessingParameterString(
            self.FOOTPRINT,
            self.tr('Footprint array'),
            defaultValue="[[1, 1, 1],\n[1, 1, 1],\n[1, 1, 1]]",
            multiLine=True,
            optional=True,
            ))

    def checkParameterValues(self, parameters, context): 
        footprintbool = self.parameterAsBool(parameters, self.BOOLFOOTPRINT, context)
        footprint = self.parameterAsString(parameters, self.FOOTPRINT, context)
        if footprintbool and not footprint.strip() == "":
            ok, _ = self.check_structure(footprint)
            if not ok:
                return (ok, self.tr('Can not parse footprint string'))
        
        return super().checkParameterValues(parameters, context)
    

    def get_parameters(self, parameters, context):
        kargs = super().get_parameters(parameters, context)

        size = self.parameterAsInt(parameters, self.SIZE, context)
        if size:
            kargs['size'] = size
        footprintbool = self.parameterAsBool(parameters, self.BOOLFOOTPRINT, context)
        footprint = self.parameterAsString(parameters, self.FOOTPRINT, context)
        if footprintbool and footprint:
            # Try to parse the Footprint
            try:
                decoded = json.loads(footprint)
                footprint = np.array(decoded, dtype=np.float32)
            except (json.decoder.JSONDecodeError, ValueError, TypeError):
                raise QgsProcessingException(self.tr('Can not parse Footprint string!'))
            kargs['footprint'] = footprint
        else:
            if not size:
                # Either size or footprint must be set
                kargs['size'] = 1

        mode = self.parameterAsInt(parameters, self.MODE, context) 
        kargs['mode'] = self.modes[mode]

        cval = self.parameterAsDouble(parameters, self.CVAL, context)
        if cval:
            kargs['cval'] = cval

        return kargs
    
 



    def createInstance(self):
        return SciPyGreyMorphologicalAlgorithm()

