# -*- coding: utf-8 -*-

"""
/***************************************************************************
 SciPyFilters
                                 A QGIS plugin
 Filter collection implemented with SciPy
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-03-03
        copyright            : (C) 2024 by Florian Neukirchen
        email                : mail@riannek.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Florian Neukirchen'
__date__ = '2024-03-03'
__copyright__ = '(C) 2024 by Florian Neukirchen'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import numpy as np
from scipy import ndimage

from scipy_filters.scipy_algorithm_baseclasses import (SciPyAlgorithmWithMode,
                                          SciPyAlgorithmWithModeAxis,
                                          Dimensions)

from scipy_filters.helpers import tr

class SciPyLaplaceAlgorithm(SciPyAlgorithmWithMode):
    """
    Multidimensional Laplace filter based on approximate second derivatives.
    Calculated with gaussian_laplace from 
    <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

    Note: No data cells within the filter radius are filled with 0.

    **Dimension** Calculate for each band separately (2D) 
    or use all bands as a 3D datacube and perform filter in 3D. 
    Note: bands will be the first axis of the datacube.

    **Border mode** determines how input is extended around 
    the edges: *Reflect* (input is extended by reflecting at the edge), 
    *Constant* (fill around the edges with a **constant value**), 
    *Nearest* (extend by replicating the nearest pixel), 
    *Mirror* (extend by reflecting about the center of last pixel), 
    *Wrap* (extend by wrapping around to the opposite edge).

    **Dtype** Data type of output. Beware of clipping 
    and potential overflow errors if min/max of output does 
    not fit. Default is Float32.
    """
    
    # Overwrite constants of base class
    _name = 'laplace'
    _displayname = tr('Laplace')
    _outputname = None # If set to None, the displayname is used 
    _groupid = "edges" 

    _default_dtype = 6 # Optionally change default output dtype (value = idx of combobox)

    
    # The function to be called, to be overwritten
    def get_fct(self):
        return ndimage.laplace
    
    
    def checkAndComplain(self, feedback):
        if self._outdtype in (1,2,4):
            msg = tr(f"WARNING: Output contains negative values, but output data type is unsigned integer!")
            feedback.reportError(msg, fatalError = False)

    def createInstance(self):
        return SciPyLaplaceAlgorithm()    


class SciPySobelAlgorithm(SciPyAlgorithmWithModeAxis):
    """
    Sobel filter
    
    Calculated with sobel from 
    <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

    Note: No data cells within the filter radius are filled with 0.

    **Dimension** Calculate for each band separately (2D) 
    or use all bands as a 3D datacube and perform filter in 3D. 
    Note: bands will be the first axis of the datacube.

    **Axis**: Find horizontal or vertical edges or in case 
    of 3D edges across the bands. Magnitude: all axes combined 
    with hypothenuse of the triangle.
    **Border mode** determines how input is extended around 
    the edges: *Reflect* (input is extended by reflecting at the edge), 
    *Constant* (fill around the edges with a **constant value**), 
    *Nearest* (extend by replicating the nearest pixel), 
    *Mirror* (extend by reflecting about the center of last pixel), 
    *Wrap* (extend by wrapping around to the opposite edge).
    
    **Dtype** Data type of output. Beware of clipping 
    and potential overflow errors if min/max of output does 
    not fit. Default is Float32.
    """
    
    # Overwrite constants of base class
    _name = 'sobel'
    _displayname = tr('Sobel')
    _outputname = None # If set to None, the displayname is used 
    _groupid = "edges" 

    _default_dtype = 6 # Optionally change default output dtype (value = idx of combobox)
    
    # The function to be called, to be overwritten
    def get_fct(self):
        return self.myfunction

    def myfunction(self, input, **kwargs):
        if self.axis_mode == 3: # Magnitude
            horiz = ndimage.sobel(input, axis=-2, **kwargs)
            vertical = ndimage.sobel(input, axis=-1, **kwargs)
            magnitude = np.hypot(horiz, vertical)
            if self._dimension == Dimensions.threeD:
                third = ndimage.sobel(input, axis=-3, **kwargs)
                magnitude = np.hypot(magnitude, third)
            return magnitude
        else:
            kwargs['axis'] = self.axis
            return ndimage.sobel(input, **kwargs)

    def checkAndComplain(self, feedback):
        if self._outdtype in (1,2,4):
            msg = tr(f"WARNING: Output contains negative values, but output data type is unsigned integer!")
            feedback.reportError(msg, fatalError = False)

    def createInstance(self):
        return SciPySobelAlgorithm()  


class SciPyPrewittAlgorithm(SciPyAlgorithmWithModeAxis):
    """
    Prewitt filter.
    Calculated with prewitt from 
    <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

    Note: No data cells within the filter radius are filled with 0.

    **Dimension** Calculate for each band separately (2D) 
    or use all bands as a 3D datacube and perform filter in 3D. 
    Note: bands will be the first axis of the datacube.

    **Axis**: Find horizontal or vertical edges or in case 
    of 3D edges across the bands. Magnitude: all axes combined 
    with hypothenuse of the triangle.
    **Border mode** determines how input is extended around 
    the edges: *Reflect* (input is extended by reflecting at the edge), 
    *Constant* (fill around the edges with a **constant value**), 
    *Nearest* (extend by replicating the nearest pixel), 
    *Mirror* (extend by reflecting about the center of last pixel), 
    *Wrap* (extend by wrapping around to the opposite edge).
    
    **Dtype** Data type of output. Beware of clipping 
    and potential overflow errors if min/max of output does 
    not fit. Default is Float32.
    """
    
    # Overwrite constants of base class
    _name = 'prewitt'
    _displayname = tr('Prewitt')
    _outputname = None # If set to None, the displayname is used 
    _groupid = "edges" 

    _default_dtype = 6 # Optionally change default output dtype (value = idx of combobox)

    
    # The function to be called, to be overwritten
    def get_fct(self):
        return self.myfunction

    def myfunction(self, input, **kwargs):

        if self.axis_mode == 3: # Magnitude
            horiz = ndimage.prewitt(input, axis=-2, **kwargs)
            vertical = ndimage.prewitt(input, axis=-1, **kwargs)
            magnitude = np.hypot(horiz, vertical)
            if self._dimension == Dimensions.threeD:
                third = ndimage.prewitt(input, axis=-3, **kwargs)
                magnitude = np.hypot(magnitude, third)
            return magnitude
        else:
            kwargs['axis'] = self.axis
            return ndimage.prewitt(input, **kwargs)
    
    def checkAndComplain(self, feedback):
        if self._outdtype in (1,2,4):
            msg = tr(f"WARNING: Output contains negative values, but output data type is unsigned integer!")
            feedback.reportError(msg, fatalError = False)

    def createInstance(self):
        return SciPyPrewittAlgorithm()  
    