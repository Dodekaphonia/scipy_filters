# -*- coding: utf-8 -*-

"""
/***************************************************************************
 SciPyFilters
                                 A QGIS plugin
 Filter collection implemented with SciPy
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-03-03
        copyright            : (C) 2024 by Florian Neukirchen
        email                : mail@riannek.de
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Florian Neukirchen'
__date__ = '2024-03-03'
__copyright__ = '(C) 2024 by Florian Neukirchen'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

import numpy as np
from osgeo import gdal
from scipy import ndimage
from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterRasterLayer,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterRasterDestination,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterBand,
                        )
from .scipy_algorithm_baseclasses import (SciPyAlgorithm,
                                          SciPyAlgorithmWithMode,
                                          SciPyAlgorithmWithModeAxis,
                                          SciPyStatisticalAlgorithm)



class SciPyMedianAlgorithm(SciPyStatisticalAlgorithm):
    # Overwrite constants of base class
    _name = 'median'
    _displayname = 'Median filter'
    _outputname = None # If set to None, the displayname is used 
    _groupid = "statistic" 
    _help = """
            Median filter.\
            Calculated with median_filter from \
            <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

            <b>Dimension</b> Calculate for each band separately (2D) \
            or use all bands as a 3D datacube and perform filter in 3D. \
            Note: bands will be the first axis of the datacube.

            <b>Size</b> Size of filter if no footprint is given. Equivalent \
            to a footprint array of shape size × size [× size in 3D] \
            filled with ones.
            
            <b>Footprint</b> String representation of array, specifiying \
            the kernel of the filter. \
            Must have 2 dimensions if <i>dimension</i> is set to 2D. \
            Should have 3 dimensions if <i>dimension</i> is set to 3D, \
            but a 2D array is also excepted (a new axis is added as first \
            axis and the result is the same as calculating each band \
            seperately).

            <b>Border mode</b> determines how input is extended around \
            the edges: <i>Reflect</i> (input is extended by reflecting at the edge), \
            <i>Constant</i> (fill around the edges with a <b>constant value</b>), \
            <i>Nearest</i> (extend by replicating the nearest pixel), \
            <i>Mirror</i> (extend by reflecting about the center of last pixel), \
            <i>Wrap</i> (extend by wrapping around to the opposite edge).
            """
    
    # The function to be called, to be overwritten
    def get_fct(self):
        return ndimage.median_filter
        
    def createInstance(self):
        return SciPyMedianAlgorithm()  


class SciPyMinimumAlgorithm(SciPyStatisticalAlgorithm):
    # Overwrite constants of base class
    _name = 'minimum'
    _displayname = 'Minimum filter'
    _outputname = None # If set to None, the displayname is used 
    _groupid = "statistic" 
    _help = """
            Minimum filter.\
            Calculated with minimum_filter from \
            <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

            <b>Dimension</b> Calculate for each band separately (2D) \
            or use all bands as a 3D datacube and perform filter in 3D. \
            Note: bands will be the first axis of the datacube.

            <b>Size</b> Size of filter if no footprint is given. Equivalent \
            to a footprint array of shape size × size [× size in 3D] \
            filled with ones.

            <b>Footprint</b> String representation of array, specifiying \
            the kernel of the filter. \
            Must have 2 dimensions if <i>dimension</i> is set to 2D. \
            Should have 3 dimensions if <i>dimension</i> is set to 3D, \
            but a 2D array is also excepted (a new axis is added as first \
            axis and the result is the same as calculating each band \
            seperately).

            <b>Border mode</b> determines how input is extended around \
            the edges: <i>Reflect</i> (input is extended by reflecting at the edge), \
            <i>Constant</i> (fill around the edges with a <b>constant value</b>), \
            <i>Nearest</i> (extend by replicating the nearest pixel), \
            <i>Mirror</i> (extend by reflecting about the center of last pixel), \
            <i>Wrap</i> (extend by wrapping around to the opposite edge).
            """
    
    # The function to be called, to be overwritten
    def get_fct(self):
        return ndimage.minimum_filter
        
    def createInstance(self):
        return SciPyMinimumAlgorithm()      
    

class SciPyMaximumAlgorithm(SciPyStatisticalAlgorithm):
    # Overwrite constants of base class
    _name = 'maximum'
    _displayname = 'Maximum filter'
    _outputname = None # If set to None, the displayname is used 
    _groupid = "statistic" 
    _help = """
            Maximum filter.\
            Calculated with maximum_filter from \
            <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

            <b>Dimension</b> Calculate for each band separately (2D) \
            or use all bands as a 3D datacube and perform filter in 3D. \
            Note: bands will be the first axis of the datacube.

            <b>Size</b> Size of filter if no footprint is given. Equivalent \
            to a footprint array of shape size × size [× size in 3D] \
            filled with ones.

            <b>Footprint</b> String representation of array, specifiying \
            the kernel of the filter. \
            Must have 2 dimensions if <i>dimension</i> is set to 2D. \
            Should have 3 dimensions if <i>dimension</i> is set to 3D, \
            but a 2D array is also excepted (a new axis is added as first \
            axis and the result is the same as calculating each band \
            seperately).

            <b>Border mode</b> determines how input is extended around \
            the edges: <i>Reflect</i> (input is extended by reflecting at the edge), \
            <i>Constant</i> (fill around the edges with a <b>constant value</b>), \
            <i>Nearest</i> (extend by replicating the nearest pixel), \
            <i>Mirror</i> (extend by reflecting about the center of last pixel), \
            <i>Wrap</i> (extend by wrapping around to the opposite edge).
            """
    
    # The function to be called, to be overwritten
    def get_fct(self):
        return ndimage.maximum_filter
        
    def createInstance(self):
        return SciPyMaximumAlgorithm() 


class SciPyPercentileAlgorithm(SciPyStatisticalAlgorithm):

    PERCENTILE = 'PERCENTILE'

    # Overwrite constants of base class
    _name = 'percentile'
    _displayname = 'Percentile filter'
    _outputname = None # If set to None, the displayname is used 
    _groupid = "statistic" 
    _help = """
            Percentile filter.\
            Calculated with percentile_filter from \
            <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

            <b>Dimension</b> Calculate for each band separately (2D) \
            or use all bands as a 3D datacube and perform filter in 3D. \
            Note: bands will be the first axis of the datacube.

            <b>Percentile</b> Percentile from 0 to 100. Negative values: \
            use 100 - given value as percentile.

            <b>Size</b> Size of filter if no footprint is given. Equivalent \
            to a footprint array of shape size × size [× size in 3D] \
            filled with ones.

            <b>Footprint</b> String representation of array, specifiying \
            the kernel of the filter. \
            Must have 2 dimensions if <i>dimension</i> is set to 2D. \
            Should have 3 dimensions if <i>dimension</i> is set to 3D, \
            but a 2D array is also excepted (a new axis is added as first \
            axis and the result is the same as calculating each band \
            seperately).

            <b>Border mode</b> determines how input is extended around \
            the edges: <i>Reflect</i> (input is extended by reflecting at the edge), \
            <i>Constant</i> (fill around the edges with a <b>constant value</b>), \
            <i>Nearest</i> (extend by replicating the nearest pixel), \
            <i>Mirror</i> (extend by reflecting about the center of last pixel), \
            <i>Wrap</i> (extend by wrapping around to the opposite edge).
            """
    
    # The function to be called, to be overwritten
    def get_fct(self):
        return ndimage.percentile_filter
    
    def insert_parameters(self, config):
        
        self.addParameter(QgsProcessingParameterNumber(
            self.PERCENTILE,
            self.tr('Percentile'),
            QgsProcessingParameterNumber.Type.Integer,
            optional=False, 
            minValue=-100,
            maxValue=100,
            defaultValue=80
            ))   
        
        super().insert_parameters(config)

    def get_parameters(self, parameters, context):
        kwargs = super().get_parameters(parameters, context)

        kwargs['percentile'] = self.parameterAsInt(parameters, self.PERCENTILE, context) 

        return kwargs
        
    def createInstance(self):
        return SciPyPercentileAlgorithm() 
    

# Disabled, needs checks. E.g. rank must be < size or footprint

class SciPyRankAlgorithm(SciPyStatisticalAlgorithm):

    RANK = 'RANK'

    # Overwrite constants of base class
    _name = 'rank'
    _displayname = 'Rank filter'
    _outputname = None # If set to None, the displayname is used 
    _groupid = "statistic" 
    _help = """
            Rank filter.\
            Calculated with rank_filter from \
            <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

            The filter calculates a histogram for the neighborhood \
            (specified by footprint or size) and returns the value \
            at the position of <i>rank</i>. 
            
            Note: a median filter is a special case with rank = 0.5 * size of the footprint.

            <b>Dimension</b> Calculate for each band separately (2D) \
            or use all bands as a 3D datacube and perform filter in 3D. \
            Note: bands will be the first axis of the datacube.

            <b>Rank</b> Index of the element in the array of the local histogram \
            to be returned. Ranges from 0 (smallest element) to \
            the size of the footprint minus one. \
            If using size instead of footprint, the resulting footprint size \
            is size raised by the power of the number of dimensions. \
            The rank parameter may be less than zero: \
            rank = -1 indicates the largest element, etc.

            <b>Size</b> Size of filter if no footprint is given. Equivalent \
            to a footprint array of shape size × size [× size in 3D] \
            filled with ones.

            <b>Footprint</b> String representation of array, specifiying \
            the kernel of the filter. \
            Must have 2 dimensions if <i>dimension</i> is set to 2D. \
            Should have 3 dimensions if <i>dimension</i> is set to 3D, \
            but a 2D array is also excepted (a new axis is added as first \
            axis and the result is the same as calculating each band \
            seperately).

            <b>Border mode</b> determines how input is extended around \
            the edges: <i>Reflect</i> (input is extended by reflecting at the edge), \
            <i>Constant</i> (fill around the edges with a <b>constant value</b>), \
            <i>Nearest</i> (extend by replicating the nearest pixel), \
            <i>Mirror</i> (extend by reflecting about the center of last pixel), \
            <i>Wrap</i> (extend by wrapping around to the opposite edge).
            """
    
    # The function to be called, to be overwritten
    def get_fct(self):
        return ndimage.rank_filter
    
    def insert_parameters(self, config):
        
        self.addParameter(QgsProcessingParameterNumber(
            self.RANK,
            self.tr('Rank'),
            QgsProcessingParameterNumber.Type.Integer,
            optional=False, 
            ))   
        
        super().insert_parameters(config)

    def get_parameters(self, parameters, context):
        kwargs = super().get_parameters(parameters, context)

        kwargs['rank'] = self.parameterAsInt(parameters, self.RANK, context) 

        return kwargs
        
    def createInstance(self):
        return SciPyRankAlgorithm() 
    



class SciPyUniformAlgorithm(SciPyAlgorithmWithMode):
    """
    Uniform filter (i.e. box filter)
    (does not have footprint)
    """

    SIZE = 'SIZE'

    # Overwrite constants of base class
    _name = 'uniform'
    _displayname = 'Uniform filter (box filter)'
    _outputname = 'Uniform filter' 
    _groupid = "blur" 
    _help = """
            Uniform filter (a.k.a. box filter or mean filter). \
            Calculated with uniform_filter from \
            <a href="https://docs.scipy.org/doc/scipy/reference/ndimage.html">scipy.ndimage</a>.

            <b>Dimension</b> Calculate for each band separately (2D) \
            or use all bands as a 3D datacube and perform filter in 3D. \
            Note: bands will be the first axis of the datacube.

            <b>Size</b> Size of filter.

            <b>Border mode</b> determines how input is extended around \
            the edges: <i>Reflect</i> (input is extended by reflecting at the edge), \
            <i>Constant</i> (fill around the edges with a <b>constant value</b>), \
            <i>Nearest</i> (extend by replicating the nearest pixel), \
            <i>Mirror</i> (extend by reflecting about the center of last pixel), \
            <i>Wrap</i> (extend by wrapping around to the opposite edge).
            """
    
    # The function to be called, to be overwritten
    def get_fct(self):
        return ndimage.uniform_filter
    
    def initAlgorithm(self, config):
        # Call the super function first
        # (otherwise input is not the first parameter in the GUI)
        super().initAlgorithm(config)

        self.addParameter(QgsProcessingParameterNumber(
            self.SIZE,
            self.tr('Size of flat structuring element (either size or footprint must be given, with footprint, size is ignored)'),
            QgsProcessingParameterNumber.Type.Integer,
            defaultValue=3, 
            optional=False, 
            minValue=2, 
            # maxValue=20, 
            ))      
        
    def get_parameters(self, parameters, context):
        kwargs = super().get_parameters(parameters, context)

        kwargs['size'] = self.parameterAsInt(parameters, self.SIZE, context)

        return kwargs

   
    def createInstance(self):
        return SciPyUniformAlgorithm()
    

